{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Website under active construction</p> <p>Please take a look around and explore the OpenMRF documentation. Just be aware that this is work in progress and more detailed information on certain aspects of the framework will be added soon. </p> <p></p> <p></p>  \ud83d\ude80 Quickstart Guide  \ud83d\udcda Wiki <p></p>"},{"location":"#welcome-to-the-openmrf-documentation-website","title":"Welcome to the OpenMRF Documentation website!","text":"<p>OpenMRF is currently under active development. A corresponding publication describing the framework in detail will be released soon. Please watch out for this publication and use it for citation once available.</p>"},{"location":"#new-to-openmrf","title":"New to OpenMRF?","text":"<p>We strongly recommend getting started by reading the Quickstart guide carefully. For more detailed information on specific topics, refer to the wiki.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>OpenMRF is a modular and vendor-neutral framework for Magnetic Resonance Fingerprinting (MRF) built on the open-source Pulseq standard. It is built upon the MATLAB version of Pulseq by Kelvin J. Layton and Maxim Zaitsev (https://doi.org/10.1002/mrm.26235). OpenMRF unifies all core components of the MRF workflow within a single MATLAB-based toolbox: flexible sequence generation, automated Bloch-based dictionary simulation, and low-rank image reconstruction. The provided tools support a wide range of contrast preparations and readouts (e.g., spiral, radial, rosette) and include integrated solutions for trajectory calibration, spin-lock modeling, slice profile simulation, and metadata storage. Designed for reproducibility and portability, OpenMRF enables easy deployment of MRF protocols across multiple scanner platforms, including Siemens and GE systems.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li><code>include_miitt/</code>: Contains the low-rank reconstruction code provided by the MIITT group and Jeffrey Fessler's MIRT toolbox. Includes an installation script. </li> <li><code>include_misc/</code>: Miscellaneous utilities and helper functions.</li> <li><code>include_pre_sim_library/</code>: Library of SLR optimized RF pulse waveforms (including <code>sigpy</code> generated pulses) and flip angle patterns for MRF. Also used to store pre-simulated slice profiles, adiabatic efficiencies and compressed dictionaries.</li> <li><code>include_pulseq_original/</code>: Copy of the official Pulseq repo (v1.5, April 01, 2025). Includes minor modifications to the plotting functions for visualizing trigger inputs/outputs.</li> <li><code>include_pulseq_toolbox/</code>: Contains standard imaging readouts (cartesian, radial, spiral, rosette) combined with various preparation modules (inversion recovery, saturation, MLEV-T2, spin-lock, adiabatic spin-lock, CEST). Also includes simulation tools for MRF dictionary generation.</li> <li><code>main_sequences/</code>: Example Pulseq sequences and reconstruction scripts.</li> <li><code>projects/</code>: Collection of projects, which were published or presented on conferences or which are currently work in progress. For your own project, we recommend creating a subfolder and saving all your scripts here.</li> <li><code>user_specifications/</code>: User specific definitions (automatically generated via <code>install_OpenMRF.m</code>), MRI system specifications (create a <code>.csv</code> file for your system's gradient limits and timings) and optionally your python cmd specifications for <code>sigpy</code> pulses.</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>MATLAB tested with R2024b and R2025a on Win11 and Ubuntu 22.04.</li> <li>Python with the <code>sigpy</code> package \u2014 required for designing SLR and adiabatic RF pulses (e.g., BIR-4). More information on the Python setup can be found here. </li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Coming soon! </p> <p></p>"},{"location":"faq/","title":"Faq","text":"<p>Coming soon!</p>"},{"location":"publications/","title":"Publications","text":"<p>Coming soon!</p>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>The following steps briefly outline how to set up OpenMRF, compile a basic sequence, and reconstruct parametric maps from the acquired data.</p>"},{"location":"quickstart/#1-fork-and-clone-the-repository","title":"1. Fork and clone the repository.","text":"<p>Go to https://github.com/HarmonizedMRI/OpenMRF and fork the repository. Then, open a terminal, navigate to the location where you want your code to live, and run  <pre><code>git clone &lt;link-to-your-forked-repo&gt;\n</code></pre></p>"},{"location":"quickstart/#2-addconfirm-system-specifications","title":"2. Add/confirm system specifications.","text":"<p>Navigate to <code>user_specifications/system_definitions</code> and check whether there exists a <code>.csv</code> file with your scanner\u2019s system specifications. If it does, still open it and double check that the specifications listed are accurate. If it doesn\u2019t, create a file for your scanner using one of the existing files as a template, and save it in the same location using the same naming convention.</p> <p>Warning</p> <p>Please be sure to double check your system specifications. Running Pulseq sequences that are compiled for a different gradient system can damage your scanner. </p> <p> If you have a <code>.asc</code> file for your scanner, add it under <code>user_specifications/system_definitions/asc_files</code>. Make sure the name matches the <code>ascfile</code> field in the corresponding scanner's <code>.csv</code> file. </p> <p><code>.asc</code> files</p> <p>You don't need an <code>.asc</code> file to compile sequences. However, if your sequence happens to result in too high PNS, your sequence might not run on the scanner. </p>"},{"location":"quickstart/#3-set-user-definitions","title":"3. Set user definitions.","text":"<p>Open Matlab, navigate to the main OpenMRF folder. Run <code>install_OpenMRF.m</code>. </p> <p>install_OpenMRF.m</p> <p>Every time you reopen Matlab, you will need to run this script first in order to be able to run any other scripts. However, after the first time, it doesn't require any user input. </p> <p>The first time you run this script, this will create multiple pop-up windows prompting you to enter your user information:</p> <ul> <li>Username: Used to sign sequences you create. Can be a combination of your first and last name, for example. Will show up in the filename of all sequences you create. </li> <li>Lab: Will be stored in the backup information for all sequences you create. If your lab isn\u2019t listed, select \u201cOther\u201d and enter your affiliation manually. </li> <li>Path to backup data: This is where all your backup data will be stored. Every time you write a sequence, a subfolder will be created here containing the .seq file needed to run the sequence on the scanner, as well as backup information necessary for reconstruction. </li> <li>Default MRI scanner: the hardware limitations of this scanner will be used per default, unless you specify a different scanner in your code. </li> </ul> <p>Scanner selection</p> <p>Every time you compile a sequence, the currently selected scanner specifications will be printed to the terminal. If the variable <code>pulseq_scanner</code> is not specified before <code>pulseq_init</code> in your sequence creation script, your default scanner will be automatically selected. More information here.</p>"},{"location":"quickstart/#4-take-a-look-around","title":"4. Take a look around!","text":"<p>OpenMRF is a comprehensive framework with many different parts to it. For getting started, we strongly recommend taking a closer look at all the different examples in the <code>main_sequences</code> folder, and especially at the example MRF sequences in <code>main_sequences/fingerprinting</code>. In every subfolder, you will find code to compile the respective sequence (usually starts with <code>pulseq_....m</code>) as well as the corresponding code for reconstruction of the acquired raw data (usually starts with <code>reco_....m</code>). </p>"},{"location":"quickstart/#5-compile-a-test-sequence","title":"5. Compile a test sequence.","text":"<p>Navigate to <code>main_sequences/fingerprinting</code> and open <code>pulseq_mrf.m</code>. At the beginning of every sequence creation script, you will define five flags:</p> <ul> <li><code>flag_backup</code>: when set to 1, a <code>.seq</code> file and all corresponding backup files are saved in a subfolder in your specified backup path. When set to 0, nothing is saved. </li> </ul> <p><code>flag_backup=2</code>;</p> <p>You may encounter comments indicating that setting <code>flag_backup=2</code> results in backing up and sending the <code>.seq</code> file. This functionality is specific to the Experimental Physics 5 group at the University of W\u00fcrzburg and won't work outside of their network - please just ignore. </p> <p>Timestamps</p> <p>You can only create one sequence per minute with this flag active, otherwise the timestamps used in the naming convention would be ambiguous (more information here).</p> <ul> <li><code>flag_report</code>: when set to 1, a timing check report will be printed to the command window. When set to 2, additional hardware checks will be performed (takes longer). </li> <li><code>flag_pns</code>: when set to 1, a PNS simulation will be performed. Only works if you have a correctly named <code>.asc</code> file in the correct file location (see here). Per default, the PNS will be simulated for an axial slice. To change this default behavior, add a line  <pre><code>pns_orientation = 'coronal';\n</code></pre></li> </ul> <p>PNS Simulation</p> <p>Even when the simulated PNS is under 100%, your sequence might not run on the scanner. Based on our experience we recommend staying under 85%. PNS can be reduced by adjusting the gradient slew rate. More information here. </p> <ul> <li><code>flag_sound</code>: when set to 1, the sound resulting from gradient vibrations when running your sequence will be simulated and played by your default speaker. </li> <li><code>flag_mrf</code>: when set to 1, an MRF dictionary is created based on your sequence, allowing you to confirm that your sequence creates your intended signal evolutions. </li> </ul>"},{"location":"quickstart/#6-acquire-data","title":"6. Acquire data.","text":"<p>For more information on how to run <code>.seq</code> files on your scanner, see https://pulseq.github.io/index.html. Export the raw data as a <code>.dat</code> file. </p> <p>Danger</p> <p>Make sure you know what you're doing before you start running Pulseq sequences on your scanner. </p> <p><code>Timing and Flip Angles</code> on Siemens scanners</p> <p>If you are using a Siemens system, make sure to set <code>Timing and Flip Angles</code> in the <code>Sequence/Special</code> tab to <code>strict</code>. Otherwise, all RF events might be rescaled if the peak RF voltage exceeds your scanner's limit. </p>"},{"location":"quickstart/#7-reconstruct-the-data-and-create-parametric-maps","title":"7. Reconstruct the data and create parametric maps.","text":"<p>In Matlab, navigate to <code>main_sequences/fingerprinting</code> and open <code>reco_mrf.m</code>. Change the variables <code>study_path</code> and <code>study_name_mrf</code> to point to your acquired data. For now, we are not correcting for trajectory imperfections, so delete or comment the line defining <code>study_name_traj</code> - in this case, the nominal trajectory will be used for reconstruction. After having updated the paths, run the file. Once the reconstruction is complete, a figure showing the final parametric maps should appear. </p>"},{"location":"quickstart/#8-your-feedback-matters","title":"8. Your feedback matters!","text":"<p>Please help us improve OpenMRF. If you encounter any bugs, issues, or limitations - send us an email or create an issue on the github page! </p>"},{"location":"references/","title":"References","text":"<p>Below is a (non-exhaustive) selection of papers central to this project. </p>"},{"location":"references/#pulseq","title":"Pulseq","text":"<ul> <li>Layton KJ, Kroboth S, Jia F, Littin S, Yu H, Leupold J, Nielsen JF, St\u00f6cker T, Zaitsev M. Pulseq: A rapid and hardware-independent pulse sequence prototyping framework. Magn Reson Med. 2017 Apr;77(4):1544-1552. doi: 10.1002/mrm.26235. Epub 2016 Jun 7. PMID: 27271292.</li> </ul>"},{"location":"references/#mr-fingerprinting","title":"MR Fingerprinting","text":"<ul> <li>Ma D, Gulani V, Seiberlich N, Liu K, Sunshine JL, Duerk JL, Griswold MA. Magnetic resonance fingerprinting. Nature. 2013 Mar 14;495(7440):187-92. doi: 10.1038/nature11971. PMID: 23486058; PMCID: PMC3602925.</li> <li>Jiang Y, Ma D, Seiberlich N, Gulani V, Griswold MA. MR fingerprinting using fast imaging with steady state precession (FISP) with spiral readout. Magn Reson Med. 2015 Dec;74(6):1621-31. doi: 10.1002/mrm.25559. Epub 2014 Dec 9. PMID: 25491018; PMCID: PMC4461545.</li> <li>Hamilton JI, Jiang Y, Chen Y, Ma D, Lo WC, Griswold M, Seiberlich N. MR fingerprinting for rapid quantification of myocardial T1 , T2 , and proton spin density. Magn Reson Med. 2017 Apr;77(4):1446-1458. doi: 10.1002/mrm.26216. Epub 2016 Apr 1. PMID: 27038043; PMCID: PMC5045735.</li> <li>Hamilton JI, Jiang Y, Ma D, Chen Y, Lo WC, Griswold M, Seiberlich N. Simultaneous multislice cardiac magnetic resonance fingerprinting using low rank reconstruction. NMR Biomed. 2019 Feb;32(2):e4041. doi: 10.1002/nbm.4041. Epub 2018 Dec 18. PMID: 30561779; PMCID: PMC7755311.</li> </ul>"},{"location":"references/#nufft","title":"NUFFT","text":"<ul> <li>Fessler JA, Sutton BP. Nonuniform fast Fourier transforms using min-max interpolation. IEEE Transactions on Signal Processing. 2003 Feb;51(2):560-574. doi: 10.1109/TSP.2002.807005.</li> </ul>"},{"location":"team/","title":"Team","text":""},{"location":"team/#maximilian-gram","title":"Maximilian Gram","text":"<p>is a postdoctoral researcher at the University Hospital W\u00fcrzburg. He received a B.Sc., M.Sc., and PhD in Physics from the University of W\u00fcrzburg. </p> Fun Fact <p>Maximilian's MR sequence design and problem solving skills far exceed his knowledge of German language intricacies. His sworn enemy is the \"Genitiv\". </p>"},{"location":"team/#tom-griesler","title":"Tom Griesler","text":"<p>is a Biomedical Engineering PhD candidate at the University of Michigan. He received a B.Sc. from the Technical University of Darmstadt and an M.Sc. from the University of W\u00fcrzburg, both in Physics. </p> Fun Fact <p>In seventh grade, Tom won a third prize in the \"Kangaroo Challenge\" mathematics competition in his high school, a success that is largely viewed as his greatest scientific achievement to date. </p>"},{"location":"troubleshoot/","title":"Troubleshooting","text":"<p>On this page, you'll find quick fixes for the most common problems you may encounter. </p> <p>Site under construction</p> <p>More will be added soon! </p> <p>Your feedback matters!</p> <p>Ran into an issue that's not listed here? Let us know!</p>"},{"location":"troubleshoot/#stimulation-limit-exceeded","title":"Stimulation limit exceeded","text":"<p>This may be one of the most common issues you'll run into. Even if you double-checked all parameters and the PNS simulation predicted moderate values, your scanner might not execute your sequence (or abort halfway through) and display a warning that the stimulation limit was exceeded. Luckily for you, in most cases this is an easy fix. You'll need to reduce the slew rate. </p>"},{"location":"wiki/","title":"Overview","text":"<p>Welcome to the OpenMRF wiki! On the left, you can select a topic that you want to learn more about - or use the search bar at the top. </p> <p>Your feedback matters!</p> <p>Not finding what you're looking for? Let us know!</p>"},{"location":"wiki/cardiac_triggering/","title":"Cardiac Triggering","text":"<p>To enable myocardial T1 and T2 mapping with MRF, the acquisition is typically split into multiple acquisition windows<sup>1</sup>. Ideally, these acquisition windows are placed in the exact same cardiac phase so that the resulting parametric maps don't show any motion corruption. In order to allow the flexible placement of the acquisition window depending on the subject's heart rate, we are using Pulseq's new soft delay feature. </p> <ol> <li> <p>Hamilton JI, Jiang Y, Chen Y, Ma D, Lo WC, Griswold M, Seiberlich N. MR fingerprinting for rapid quantification of myocardial T1 , T2 , and proton spin density. Magn Reson Med. 2017 Apr;77(4):1446-1458. doi: 10.1002/mrm.26216.\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/custom_trajectories/","title":"Custom Trajectories","text":"<p>The SPI readout module offers three options for the design of k-space trajectories, which can be selected by setting the variable <code>SPI.geo.traj_mode</code> to one of the following three options before running the <code>SPI_init()</code> function:</p> <ul> <li><code>'standard'</code>: calls <code>SPI_traj_standard.m</code> to create a spiral trajectory based on geometric parameters, following the formulation by Kai Tobias Block<sup>1</sup>. </li> <li><code>'vds'</code>: calls <code>SPI_traj_vds.m</code> to create a variable-density spiral based on geometric parameters and system specifications, using Brian Hargreaves' VDS toolbox <sup>2</sup>.  </li> <li><code>'import'</code>: calls <code>SPI_traj_import.m</code> to allow the import of custom trajectories. In order to use this feature, the parameter <code>SPI.geo.path</code> must be set to the path of a <code>.mat</code> file containing two variables: <code>dur</code> (the desired duration of the readout in seconds), and either <code>gxy</code> (the gradient waveform as a complex array) or <code>kxy</code> (the k-space trajectory as a complex array). </li> </ul> <p>Warning</p> <p>Importing custom trajectories is an experimental feature - use with care, desired performance cannot be guaranteed. Will likely be updated in future versions. </p> <ol> <li> <p>KT Block. Spiralf\u00f6rmige Abtastung des k-Raumes bei der Magnetresonanz-Tomographie. Diploma thesis, Georg-August-Universit\u00e4t zu G\u00f6ttingen. 2004. https://www.mpinat.mpg.de/597698/tblock_diploma.pdf (accessed November 30, 2025).\u00a0\u21a9</p> </li> <li> <p>Unfortunately, the original toolbox cannot be found anymore under the former link http://mrsrl.stanford.edu/~brian/vdspiral/.\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/dictionary_generation/","title":"Dictionary Generation","text":"<p>Coming soon!</p>"},{"location":"wiki/modules/","title":"Modules","text":"<p>OpenMRF is a modular framework. All magnetization preparation and readout modules are implemented as Matlab structs and follow a similar structure. </p> <p>Module vs. instance</p> <p>The Matlab structure defines the module. If your sequence features a specific module more than once, you do not need to initialize them individually. See code examples below.</p>"},{"location":"wiki/modules/#overview-of-module-names","title":"Overview of module names","text":""},{"location":"wiki/modules/#magnetization-preparations","title":"Magnetization preparations","text":"<p>The source code for the following modules can be found in <code>include_pulseq_toolbox/src_preparations</code>. </p> Module Name Long Name Notes ADIASL Adiabatic Spin Lock Defines an adiabatic spin lock module for T1\\(\\rho\\) preparation CEST Chemical Exchange Saturation Transfer CRUSH Crusher FAT Fat suppression INV Inversion MLEV Malcolm Levitt Defines a T2\\(\\rho\\) preparation featuring Malcolm Levitt phase cycling. SAT Saturation SL Spin Lock Defines a continuous wave spin lock module for T1\\(\\rho\\) preparation. T2 T2 preparation"},{"location":"wiki/modules/#readouts","title":"Readouts","text":"<p>The source code for the following modules can be found in <code>include_pulseq_toolbox/src_readouts</code>. </p> Module Name Long Name Notes EPI Echo Planar Imaging PRESS Point Resolved Spectroscopy RAD Radial SPI Spiral Used for spiral and custom non-Cartesian trajectories. More information here. SPITSE Spiral Turbo Spin Echo TSE Turbo Spin Echo UTE Ultra short TE"},{"location":"wiki/modules/#other","title":"Other","text":"<p>The source code for the following modules can be found in <code>include_pulseq_toolbox/src_misc</code>.</p> Module Name Long Name Notes FOV Field of view Defines the field of view geometry. TRAJ Trajectory Used for trajectory calibration. WASABI Waserstein based anatomical brain Index Used for simultaneous B0 and B1 mapping."},{"location":"wiki/modules/#the-_init-function","title":"The <code>..._init()</code> function","text":"<p>Before they can be added to a sequence, all magnetization preparations and readouts have to be initialized.  The first step is to create the structure. Second, the respective <code>..._init()</code> function is called, with the respective structure as the first input argument. You don't have to define all parameters of the module yourself - optional parameters have a default value that will be assigned by the <code>..._init()</code> function unless specified explicitly. When in doubt, just look at the source code of the module in question.</p> <p>Multiple instances of the same preparation module</p> <p>If you are planning to add multiple instances of the same magnetization preparation module with different preparation times (as often done in cardiac &amp; abdominal MRF), you can initialize them all at once by making the respective field an array instead of a single value. See examples below. </p> <p>The following two examples show how advanced magnetization preparations can be easily initialized in OpenMRF:</p> Hyperbolic Secant InversionAdiabatic BIR4 T2 preparation <pre><code>INV.rf_type      = 'HYPSEC_inversion';\nINV.tExc         = 10 *1e-3;  % [s]  hypsec pulse duration\nINV.beta         = 700;       % [Hz] maximum rf peak amplitude\nINV.mu           = 4.9;       % [ ]  determines amplitude of frequency sweep\nINV.inv_rec_time = [15 75 150 250] *1e-3;\nINV = INV_init(INV, FOV, system);\n</code></pre> <pre><code>T2.exc_mode   = 'adiabatic_BIR4';\nT2.rfc_dur    = 2 *1e-3;   % [s]  duration of composite refocusing pulses\nT2.bir4_tau   = 10 *1e-3;  % [s]  bir4 pulse duration\nT2.bir4_f1    = 640;       % [Hz] maximum rf peak amplitude\nT2.bir4_beta  = 10;        % [ ]  am waveform parameter\nT2.bir4_kappa = atan(10);  % [ ]  fm waveform parameter\nT2.bir4_dw0   = 30000;     % [rad/s] fm waveform scaling\nT2.prep_times = [40 80] * 1e-3;  % [s] inversion times\nT2            = T2_init(T2, FOV, system);\n</code></pre> <p>This example shows how to define and initialize a spiral readout with golden angle interleaves for MRF:  <pre><code>% import params from MRF struct\nSPI.nr             = MRF.nr;    % [ ] number of readouts per heart beat\nSPI.NR             = MRF.NR;    % [ ] number of repetitions\nSPI.mrf_import.TRs = MRF.TRs;   % [s] repetition times\nSPI.mrf_import.FAs = MRF.FAs;   % [rad] flip angles\n\n% slice excitation\nSPI.exc_mode      = 'sinc';      % 'sinc' or 'sigpy_SLR'\nSPI.exc_time      = 0.8 *1e-3;   % [s] excitation time\nSPI.exc_tbw       = 2;           % [ ] time bandwidth product\nSPI.exc_fa_mode   = 'import';    % 'equal',  'ramped',  'import' \nSPI.lim_gz_slew   = 0.9;         % [ ] reduce stimulation during slice excitation\nSPI.lim_reph_slew = 0.9;         % [ ] reduce stimulation during slice rephaser\n\n% gradient spoiling\nSPI.spoil_nTwist   = 4;          % [ ] number of 2pi twists in z-direction, 0 for balanced\nSPI.spoil_duration = 0.8 *1e-3;  % [s] time for spoiler and rewinder gradients\nSPI.lim_spoil_slew = 0.9;        % [ ] reduce stimulation during gradient spoiling\n\n% rf spoiling\nSPI.spoil_rf_mode = 'lin';      % rf spoiling mode: 'lin' or 'quad'\nSPI.spoil_rf_inc  = 0 *pi/180;  % rf spoiling increment [rad]\n\n% spiral geometry mode\nSPI.geo.interleave_mode = 'RoundGoldenAngle';\nSPI.geo.traj_mode       = 'vds';\n\n% vds parameters\nSPI.Nunique       = 48;            % number of unique projection angles\nSPI.deltak        = 1/FOV.fov_xy;  % [1/m] kspace sampling\nSPI.kmax          = SPI.deltak * FOV.Nxy/2;\nSPI.geo.Nvds      = 24;            % number of vds-spirals for sampling the kspce center\nSPI.geo.BW        = 500 *1e3;      % [Hz] bandwidth of spiral acquisition\nSPI.geo.Fcoeff    = [1  -0.5];     % [1 0] for archimedean (equal density), [1 -0.5] for logarithmic (variable density)\nSPI.geo.grad_lim  = 1/sqrt(3);     % limit of gradient field strength\nSPI.geo.slew_lim  = 1/sqrt(3);     % limit of slew rate\nSPI.geo.kmax      = SPI.kmax;      % determines resolution\nSPI.geo.t_dwell   = 1/SPI.geo.BW;  % [s] dwell time for spiral acquisition\n\n[SPI, ktraj_adc, ktraj_full, ktraj_reco] = SPI_init(SPI, FOV, system, 1);\n</code></pre></p>"},{"location":"wiki/modules/#the-_add-function","title":"The <code>..._add()</code> function","text":"<p>When building a sequence, instances of a module can be added using the respective <code>..._add()</code> function. If your sequence features multiple instances of the same magnetization preparation module, a counter is increased automatically to ensure that each instance is added with the correct preparation time. </p> <p>Tip</p> <p>Take a closer look at <code>main_sequences/fingerprinting/pulseq_mrf.m</code> and <code>main_sequences/fingerprinting/pulseq_cmrf.m</code> to understand the use of magnetization preparation and readout modules. </p>"},{"location":"wiki/noise_prewhitening/","title":"Noise Prewhitening","text":"<p>Info</p> <p>Currently only implemented for use with the SPI readout module. </p> <p>OpenMRF allows the easy inclusion of noise pre-whitening into your sequence. In all example sequences using the SPI readout module, this will be active per default. It requires two steps:</p> <ol> <li>In the sequence creation script, add the noise pre-scans after initializing the SPI readout module and before adding any other objects to the sequence structure.  <pre><code>SPI.Nnoise = 16;\nSPI_add_prescans();\n</code></pre></li> <li>In the reconstruction script, check for pre-scans during raw data read in and, if applicable, perform the pre-whitening operation. </li> </ol> Without noise pre-whiteningWith noise pre-whitening <pre><code>DATA = SPI_get_rawdata(twix_obj, Nnoise);\nDATA = permute(DATA, [3,1,2]);\nDATA(:,:,1:adcNPad)  = [];     % adc padding\n</code></pre> <pre><code>if isfield(PULSEQ.SPI, 'Nnoise')\n    Nnoise = PULSEQ.SPI.Nnoise;\nelse\n    Nnoise = 0;\nend\n[DATA, ~, ~, ~, NOISE] = SPI_get_rawdata(twix_obj, Nnoise);\nDATA = permute(DATA, [3,1,2]); % mrf rawdata\nDATA(:,:,1:adcNPad)  = [];     % adc padding\n\n% noise pre-whitening\nif ~isempty(NOISE)\n    NOISE = permute(NOISE, [3,1,2]);  % permute noise prescans\n    NOISE(:,:,1:adcNPad) = [];        % adc padding\n    DATA = mg_noise_prewhitIening(DATA, NOISE, 'cholesky', 1);\nend\nclear NOISE;\n</code></pre>"},{"location":"wiki/python/","title":"Python Setup","text":"<p>Coming soon! </p>"},{"location":"wiki/scanner/","title":"Scanner selection","text":"<p>If the variable <code>pulseq_scanner</code> is not specified in your sequence creation script before <code>pulseq_init</code>, your default scanner will be selected. </p> <p>Default scanner</p> <p>The default scanner is set when you first run <code>install_OpenMRF.m</code>. It can be changed later by modifying the corresponding field in <code>user_specifications/user_definitions/pulseq_user_definitions.csv</code>.  </p> <p>You can compile a sequence for a scanner that is not set as your default by explicitly setting the variable <code>pulseq_scanner</code> to the name of an alternative scanner. See the following example. Assume the default scanner is set to <code>'Siemens_Sola_1,5T_MIITT'</code>. </p> Use default scannerUse alternative scanner <p>pulseq_mrf.m<pre><code>%% init pulseq\nclear\nseq_name = 'mrf_';\n\n% optional flags\nflag_backup = 0; % 0: off,  1: only backup\nflag_report = 0; % 0: off,  1: only timings, 2: full report (slow)\nflag_pns    = 0; % 0: off,  1: simulate PNS stimulation\nflag_sound  = 0; % 0: off,  1: simulate gradient sound\nflag_mrf    = 0; % 0: off,  1: simulate sequence via MRF toolbox\n\n% init system, seq object and load pulseq user information\npulseq_init();\n</code></pre> This will set the system specifications to the values defined in <code>user_specifications/system_definitions/Siemens_Sola_1,5T_MIITT.csv</code>.</p> <p>pulseq_mrf.m<pre><code>%% init pulseq\nclear\nseq_name = 'mrf_';\n\n% optional flags\nflag_backup = 0; % 0: off,  1: only backup\nflag_report = 0; % 0: off,  1: only timings, 2: full report (slow)\nflag_pns    = 0; % 0: off,  1: simulate PNS stimulation\nflag_sound  = 0; % 0: off,  1: simulate gradient sound\nflag_mrf    = 0; % 0: off,  1: simulate sequence via MRF toolbox\n\npulseq_scanner = 'Siemens_FreeMax_0,55T_MIITT';\n\n% init system, seq object and load pulseq user information\npulseq_init();\n</code></pre> This will set the system specifications to the values defined in <code>user_specifications/system_definitions/Siemens_FreeMax_0,55T_MIITT.csv</code>.</p> <p>Scanner selection</p> <p>Never run a sequence on a scanner that it was not compiled for. While your scanner should usually detect if a sequence exceeds certain limits, this can't be guaranteed, and you risk damaging your system. </p>"},{"location":"wiki/spiral_mapping/","title":"Spiral Single Parameter Mapping","text":"<p>OpenMRF includes sequences and reconstruction code for fast single parameter T1, T2, and T1\\(\\rho\\) mapping. </p>"},{"location":"wiki/timestamps/","title":"Timestamps","text":"<p>In order to be able to later connect data acquired with an OpenMRF sequence with the corresponding metadata required for reconstruction and parameter mapping, each <code>.seq</code> file and corresponding backup folder include the timestamp of its creation in the filenames. This timestamp will be written into the data exported from the scanner (so far only validated for Siemens) and allow a seamless reconstruction. </p> <p>Warning</p> <p>If you're trying to compile more than one sequence per minute, you will receive the following warning: <code>Warning: pulseq duplicate detected! .seq writing stopped!</code>.</p>"},{"location":"wiki/trajectory/","title":"Trajectory Calibration","text":"<p>Warning</p> <p>Site under construction</p> <p>OpenMRF offers the option to calibrate your trajectory. This feature is especially relevant if you're using demanding gradient operations at higher field strengths. In the following, we'll outline the process in five easy steps. </p>"},{"location":"wiki/trajectory/#1-mrf-sequence-creation","title":"1. MRF sequence creation.","text":"<p>Compile any MRF sequence that you want to use for data acquisition. Make sure <code>flag_backup</code> is set to 1. </p>"},{"location":"wiki/trajectory/#2-trajectory-calibration-sequence-creation","title":"2. Trajectory calibration sequence creation.","text":"<p>Open <code>main_sequences/calibrate_trajectories/pulseq_traj_meas.m</code>. In the second cell, change the path of the SPI object to be loaded to the backup <code>.mat</code> file corresponding to the MRF sequence in question. </p>"},{"location":"wiki/trajectory/#3-measurement","title":"3. Measurement","text":""},{"location":"wiki/trajectory/#4-reconstruction-standalone-optional","title":"4. Reconstruction - standalone (optional)","text":""},{"location":"wiki/trajectory/#5-use-in-mrf-reconstruction","title":"5. Use in MRF reconstruction","text":""}]}